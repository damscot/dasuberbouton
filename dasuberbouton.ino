#include <RH_ASK.h>
#include <SPI.h> // Not actualy used but needed to compile
#include <Adafruit_NeoPixel.h>


// Digital pins
#define PIXELPIN            6
#define BOUTONSW_PIN        5
#define MAX7219_CLK_PIN     7
#define MAX7219_CS_PIN      9
#define MAX7219_DIN_PIN     8

// How many NeoPixels are attached to the Arduino?
#define NUMPIXELS      5

// Analog Pins
#define PHOTOR0_PIN 0
#define PHOTOR1_PIN 1
#define PHOTOR2_PIN 2
#define PHOTOR3_PIN 3
#define PHOTOR4_PIN 4
#define BOUTONX_PIN 5
#define BOUTONY_PIN 6

// When we setup the NeoPixel library, we tell it how many pixels, and which pin to use to send signals.
// Note that for older NeoPixel strips you might need to change the third parameter--see the strandtest
// example for more information on possible values.
Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, PIXELPIN, NEO_GRB + NEO_KHZ800);
RH_ASK RH_driver = RH_ASK(2000, 11, 12, 10, false);

unsigned char i;
unsigned char j;

/*Port Definitions*/


#if 1

unsigned char disp1[49][8] = 
{
  {0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C},//0
  {0x08,0x18,0x28,0x08,0x08,0x08,0x08,0x3e},//1
  {0x7E,0x2,0x2,0x7E,0x40,0x40,0x40,0x7E},//2
  {0x3e,0x02,0x02,0x1e,0x02,0x02,0x02,0x3e},//3
  {0x8,0x18,0x28,0x48,0xFE,0x8,0x8,0x8},//4
  {0x7e,0x40,0x40,0x7c,0x02,0x02,0x02,0x7c},//5
  {0x7e,0x40,0x40,0x7e,0x42,0x42,0x42,0x7e},//6
  {0x7e,0x02,0x04,0x08,0x10,0x10,0x10,0x10},//7
  {0x7e,0x42,0x42,0x7e,0x42,0x42,0x42,0x7e},//8
  {0x7e,0x42,0x42,0x7e,0x02,0x02,0x02,0x7e},//9
  {0x8,0x14,0x22,0x3E,0x22,0x22,0x22,0x22},//A
  {0x3C,0x22,0x22,0x3E,0x22,0x22,0x3C,0x0},//B
  {0x3C,0x40,0x40,0x40,0x40,0x40,0x3C,0x0},//C
  {0x7C,0x42,0x42,0x42,0x42,0x42,0x7C,0x0},//D
  {0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x7C},//E
  {0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x40},//F
  {0x3C,0x40,0x40,0x40,0x40,0x44,0x44,0x3C},//G
  {0x44,0x44,0x44,0x7C,0x44,0x44,0x44,0x44},//H
  {0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x7C},//I
  {0x3C,0x8,0x8,0x8,0x8,0x8,0x48,0x30},//J
  {0x0,0x24,0x28,0x30,0x20,0x30,0x28,0x24},//K
  {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7C},//L
  {0x81,0xC3,0xA5,0x99,0x81,0x81,0x81,0x81},//M
  {0x0,0x42,0x62,0x52,0x4A,0x46,0x42,0x0},//N
  {0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C},//O
  {0x3C,0x22,0x22,0x22,0x3C,0x20,0x20,0x20},//P
  {0x1C,0x22,0x22,0x22,0x22,0x26,0x22,0x1D},//Q
  {0x3C,0x22,0x22,0x22,0x3C,0x24,0x22,0x21},//R
  {0x0,0x1E,0x20,0x20,0x3E,0x2,0x2,0x3C},//S
  {0x0,0x3E,0x8,0x8,0x8,0x8,0x8,0x8},//T
  {0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x1C},//U
  {0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18},//V
  {0x0,0x49,0x49,0x49,0x49,0x2A,0x1C,0x0},//W
  {0x0,0x41,0x22,0x14,0x8,0x14,0x22,0x41},//X
  {0x41,0x22,0x14,0x8,0x8,0x8,0x8,0x8},//Y
  {0x0,0x7F,0x2,0x4,0x8,0x10,0x20,0x7F},//Z
  {0x02,0x04,0x04,0x02,0x00,0xfd,0xfd,0x00},//cloppe
  {0x20,0x10,0x10,0x47,0x45,0x47,0x44,0x7c},//cafe
  {0x00,0x54,0xd6,0x92,0x92,0xd6,0x44,0x10},//urgence
  {0x3c,0x7e,0x7e,0x00,0x7e,0x00,0x7e,0x7e},//repas
  {0x38,0x44,0x44,0x92,0x92,0x92,0xaa,0x38},//cloche
  {0x3c,0x42,0xa5,0x81,0xa5,0x99,0x42,0x3c},//smiley :-)
  {0x3c,0x42,0xa5,0x81,0xbd,0x81,0x42,0x3c},//smiley :-|
  {0x3c,0x42,0xa5,0x81,0x99,0xa5,0x42,0x3c},//smiley :-(
  {0xe7,0x81,0x81,0x81,0x99,0x81,0x81,0xe7},// [-]
  {0x81,0x3c,0x42,0x5a,0x5a,0x42,0x3c,0x81},// target
  {0xff,0x81,0xbd,0xa5,0xad,0xa1,0xbf,0x80},// spiral
  {0x00,0x3c,0x00,0x00,0x18,0x24,0x42,0x81},// montain
  {0x00,0x38,0x44,0xc3,0xff,0x44,0x00,0x00},// car
  };

#else

unsigned char disp1[38][8]={
{0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C},//0
{0x10,0x18,0x14,0x10,0x10,0x10,0x10,0x10},//1
{0x7E,0x2,0x2,0x7E,0x40,0x40,0x40,0x7E},//2
{0x3E,0x2,0x2,0x3E,0x2,0x2,0x3E,0x0},//3
{0x8,0x18,0x28,0x48,0xFE,0x8,0x8,0x8},//4
{0x3C,0x20,0x20,0x3C,0x4,0x4,0x3C,0x0},//5
{0x3C,0x20,0x20,0x3C,0x24,0x24,0x3C,0x0},//6
{0x3E,0x22,0x4,0x8,0x8,0x8,0x8,0x8},//7
{0x0,0x3E,0x22,0x22,0x3E,0x22,0x22,0x3E},//8
{0x3E,0x22,0x22,0x3E,0x2,0x2,0x2,0x3E},//9
{0x8,0x14,0x22,0x3E,0x22,0x22,0x22,0x22},//A
{0x3C,0x22,0x22,0x3E,0x22,0x22,0x3C,0x0},//B
{0x3C,0x40,0x40,0x40,0x40,0x40,0x3C,0x0},//C
{0x7C,0x42,0x42,0x42,0x42,0x42,0x7C,0x0},//D
{0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x7C},//E
{0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x40},//F
{0x3C,0x40,0x40,0x40,0x40,0x44,0x44,0x3C},//G
{0x44,0x44,0x44,0x7C,0x44,0x44,0x44,0x44},//H
{0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x7C},//I
{0x3C,0x8,0x8,0x8,0x8,0x8,0x48,0x30},//J
{0x0,0x24,0x28,0x30,0x20,0x30,0x28,0x24},//K
{0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7C},//L
{0x81,0xC3,0xA5,0x99,0x81,0x81,0x81,0x81},//M
{0x0,0x42,0x62,0x52,0x4A,0x46,0x42,0x0},//N
{0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C},//O
{0x3C,0x22,0x22,0x22,0x3C,0x20,0x20,0x20},//P
{0x1C,0x22,0x22,0x22,0x22,0x26,0x22,0x1D},//Q
{0x3C,0x22,0x22,0x22,0x3C,0x24,0x22,0x21},//R
{0x0,0x1E,0x20,0x20,0x3E,0x2,0x2,0x3C},//S
{0x0,0x3E,0x8,0x8,0x8,0x8,0x8,0x8},//T
{0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x1C},//U
{0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18},//V
{0x0,0x49,0x49,0x49,0x49,0x2A,0x1C,0x0},//W
{0x0,0x41,0x22,0x14,0x8,0x14,0x22,0x41},//X
{0x41,0x22,0x14,0x8,0x8,0x8,0x8,0x8},//Y
{0x0,0x7F,0x2,0x4,0x8,0x10,0x20,0x7F},//Z
};
 
#endif
 
void Write_Max7219_byte(unsigned char DATA) 
{   
            unsigned char i;
	    digitalWrite(MAX7219_CS_PIN,LOW);		
	    for(i=8;i>=1;i--)
          {		  
             digitalWrite(MAX7219_CLK_PIN,LOW);
             digitalWrite(MAX7219_DIN_PIN,DATA&0x80);// Extracting a bit data
             DATA = DATA<<1;
             digitalWrite(MAX7219_CLK_PIN,HIGH);
           }                                 
}
 
 
void Write_Max7219(unsigned char address,unsigned char dat)
{
        digitalWrite(MAX7219_CS_PIN,LOW);
        Write_Max7219_byte(address);           //address，code of LED
        Write_Max7219_byte(dat);               //data，figure on LED 
        digitalWrite(MAX7219_CS_PIN,HIGH);
}
 
void Init_MAX7219(void)
{
 Write_Max7219(0x09, 0x00);       //decoding ：BCD
 Write_Max7219(0x0a, 0x03);       //brightness 
 Write_Max7219(0x0b, 0x07);       //scanlimit；8 LEDs
 Write_Max7219(0x0c, 0x01);       //power-down mode：0，normal mode：1
 Write_Max7219(0x0f, 0x00);       //test display：1；EOT，display：0
}
 
 
 
void setup()
{
  Serial.begin(115200); // Initialisation du port série pour avoir un retour sur le serial monitor
  pinMode(MAX7219_CLK_PIN,OUTPUT);
  pinMode(MAX7219_CS_PIN,OUTPUT);
  pinMode(MAX7219_DIN_PIN,OUTPUT);
  Serial.println("Radiohead initialization");
  if (!RH_driver.init())
         Serial.println("Radiohead init failed");
  pixels.begin(); // This initializes the NeoPixel library.
  
  Serial.println("LED Matrix initialization");
  Init_MAX7219();
  for(int i=1;i<9;i++) {
    Write_Max7219(i,disp1[46][i-1]);
  }
  Serial.println("RGB LED initialization");
  for(int i=0;i<NUMPIXELS;i++){
    pixels.setPixelColor(i, pixels.Color(8,16,24));
  }
  pixels.show(); // This sends the updated pixel color to the hardware.
}
 
 
void loop()
{
    int BoutonX, BoutonY, BoutonSW;
    int Photo_R0, Photo_R1, Photo_R2, Photo_R3, Photo_R4;
    const char *msg = "hello";  
    uint8_t buf[RH_ASK_MAX_MESSAGE_LEN];
    uint8_t buflen = sizeof(buf);
    
    RH_driver.send((uint8_t *)msg, strlen(msg));
    RH_driver.waitPacketSent();
    delay(200);    
    
    if (RH_driver.recv(buf, &buflen)) // Non-blocking
    {
	int i;
	// Message with a good checksum received, dump it.
	RH_driver.printBuffer("Receive:", buf, buflen);
    }
    
    BoutonX = analogRead(BOUTONX_PIN);
    BoutonY = analogRead(BOUTONY_PIN);
    BoutonSW = digitalRead(BOUTONSW_PIN);
    Serial.print("Bouton\t");
    Serial.print("X:");
    Serial.print(BoutonX);
    Serial.print("\t");
    Serial.print("Y:");
    Serial.print(BoutonY);
    Serial.print("\t");
    Serial.print("SW:");
    Serial.print(BoutonSW);
    Serial.print("\n");
    
    Photo_R0 = analogRead(PHOTOR0_PIN);
    Photo_R1 = analogRead(PHOTOR1_PIN);
    Photo_R2 = analogRead(PHOTOR2_PIN);
    Photo_R3 = analogRead(PHOTOR3_PIN);
    Photo_R4 = analogRead(PHOTOR4_PIN);
    
    Serial.print("Photo\n");
    Serial.print("0:");
    Serial.print(Photo_R0);
    Serial.print("\t");
    Serial.print("1:");
    Serial.print(Photo_R1);
    Serial.print("\t");
    Serial.print("2:");
    Serial.print(Photo_R2);
    Serial.print("\t");
    Serial.print("3:");
    Serial.print(Photo_R3);
    Serial.print("\t");
    Serial.print("4:");
    Serial.print(Photo_R4);
    Serial.print("\n");
    
    for(int i=0;i<NUMPIXELS;i++){
      pixels.setPixelColor(i, pixels.Color(8*(BoutonX/255),16*(BoutonY/255),24*((BoutonX-BoutonY)/255)));
    }
    pixels.show();
    
#if 0

  for(j=38;j<49;j++)
  {
   for(i=1;i<9;i++)
    Write_Max7219(i,disp1[j][i-1]);
   delay(2000);
  }

  for(int i=0;i<NUMPIXELS;i++){
    //pixels.setPixelColor(((i-1)%(NUMPIXELS-1)), pixels.Color(0,0,0));
    for(int j=0;j<8;j++){
    for(int k=0;k<8;k++){
    for(int l=0;l<8;l++){  
    // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255
    pixels.setPixelColor(i, pixels.Color(j*8,k*8,l*8)); // Moderately bright green color.

    pixels.show(); // This sends the updated pixel color to the hardware.

    delay(5); // Delay for a period of time (in milliseconds).
    }
    }
    }
  } 

#endif

		
}


